# Introduction

**Bidirectional Remote Procedure Call** (biRPC) は協調型 P2P システム向けに設計されたシンプルな RPC プロトコルです。以下のような特徴を持ちます。

* **双方向性**: 通信の両端点でリモート呼び出し可能な機能を提供し双方から利用する。
* **ストリーム**: ファイルのような大きなデータをストリームとして送受信する。
* **省リソース**: 単一の TCP/IP セッション上で複数の RPC 呼び出しを同時に実行する。
* **抽象性**: TCP, UDP, Unix Pipe や標準入出力など下層のプロトコルに依存しない。

biRPC は非同期メッセージングプロトコルです。一般的な RPC の実装モデルである Request/Response を包含しながらストリーム転送も可能な設計を目的としています。

## Structure

![class chart](https://raw.github.com/torao/kazzla/master/doc/images/biRPC-ClassChart.png)

### Session

**セッション** は論理的な通信端点の状態を保持します。これは TCP/IP の実装での Socket とおなじスコープを持ちます。非同期 I/O フレームワークとはキューされており、通信相手から受信したメッセージでパイプの生成、破棄、転送を行います。

セッションには通信相手側から呼び出し可能な機能として 16 ビット整数で識別される複数の Function をバインドすることが出来ます。

### Pipe

**パイプ** は同一セッション上の通信端点がメッセージの宛先を示すために使用する仮想的な接続です。スコープは 1 function call と等価です。

パイプは通信端点の双方で共有する 16 ビットの識別子によって特定されます。相手側とのネゴシエーションなしに片方の端点単独でユニークなパイプ識別子を決定できるようにパイプ識別子の最上位ビットの使用について事前の取り決めが必要です。一般的な TCP/IP を用いた通信では接続を開始した側 (クライアント側) が 0x0000 マスク、通信を受けた側 (サーバ側) が 0x8000 マスクを使用します。これは同一セッション上で片方の端点からオープンできるパイプは最大でも 0x7FFF 個であることも意味しています。

### Messages

biRPC で使用するメッセージは 3 種類あります。一つ目は **Open** であり、通信相手とのセッション上で特定の function との仮想的なパイプ (接続) を開始する命令です。Open メッセージはこれから形成しようとしているパイプの識別子、呼び出そうとしている function 識別子、function に渡すパラメータで構成されています。

二つ目のメッセージは **Close** です。セッション上でオープンされている特定のパイプがこれ以上使われなくなった事を示すために使用されます。Close メッセージは閉じようとしているパイプ識別子と function の実行結果またはエラー状況を知らせる文字列が付属します。Open に対して単純に Close で応答する手順は一般的な Request/Response で実現される RPC プロトコルのモデルと同じです。

三つ目のメッセージは **Block** です。オープン中のパイプに対してデータブロックを送信または受信するために使用されます。Block は宛先となるパイプ識別子に加えてデータを持ちます。

Block はパイプ上で抽象化されたデータストリームを形成することを目的としたメッセージです。パイプに対して双方向の通信チャネルとして利用できます。TCP/IP のパケットと同様に下層の通信レイヤーの実装によっては複数の Block に分割されたり一つの Block に統合される可能性がありますが順序性は保障されています (下層の I/O フレームワークによって保障される必要があります)。長さが 0 の Block はストリームの終端 (EOF) を意味します。Open によって呼び出された function は、自分が起動されたパイプからこのストリームを利用することが出来ます。

## Example
### Asynchronous RPC
例としてセッション中の通信端点 A, B があり、B 側に大文字を小文字に変換する function (識別子100) が提供されているものとします。この機能を A から利用する時のメッセージの流れは以下のようになります。

![Function-Call Style](https://raw.github.com/torao/kazzla/master/doc/images/biRPC-Sequence1.png)

A は空いているパイプ識別子 10 を新たな呼び出しのために割り当てメッセージ Open(10, 100, "ABC") を送信し直ちに終了します。B は新しいパイプ 10 を割り当て自身が提供している function 100 を実行しメッセージ Close(10, "abc") を送信してパイプ 10 を破棄します。A はこの Close を受信するとパイプ 10 を破棄し実行結果 "abc" をコールバックします。

このような Open-Close の単純なセットから成る実行は非同期型の RPC と同じです。

### Asynchronous Streaming RPC
次にパイプ上に形成されたストリームを利用して A から B へファイルのような大きなデータを送信する場合のメッセージの流れを考えます。

1. A → Open(1,20) → B
2. A → Block(1,binary[32088]) → B
3. A → Block(1,binary[198]) → B
4. …
5. A → Block(1,binary[0]) → B
6. A ← Close(1,58409) ← B

上記は Open メッセージで function 20 へのパイプを形成し、そのパイプ識別子 1 に対して A から B へ任意数のデータブロックを送信している。A は最後に 0 バイトのブロックを送信することで B 側がストリームの終端を認識し最終的に受信したバイト数 58409 を返しています。

### Bidirectional Streaming, Recursive RPC
より複雑な処理では 1 つのパイプ上で双方向に Block が流れるでしょう。また B の function 実行中に A 側の function を呼び出すことも出来ます。

Close は上記の例で A からも B からも送信することが出来るが、デザイン上 Open を受けた方から送信されるのが望ましい。

* TODO 書きかけ。例示のシーケンス図作成。

## Data Presentation

### Supported Data-Type

## 雑記
### セキュリティ
biRPC ではセキュリティについての定義は行いません。通信経路上の暗号化及び通信相手の認証は下層の I/O フレームワークでの SSL/TLS レイヤーで行うことを前提としています。あるいは上層のアプリケーションレイヤーで独自の認証機構を実装する必要があります。

### 負荷分散
TCP セッションごとにクラスタ化された複数のノードへ処理を分散させることが可能です。また function に冪等性があるならばメッセージのフレームを認識しパイプ識別子ごとに分散させることが可能です。