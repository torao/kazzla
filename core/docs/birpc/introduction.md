# biRPC Protocol Design and Specification

## Introduction

**Bidirectional Remote Procedure Call** (biRPC) は協調型 P2P システム向けに設計されたシンプルな RPC プロトコルです。以下のような特徴を持ちます。

* **RPC**: 一般的な RPC の実装モデルである Request-Response 型を包含する。
* **双方向性**: 通信の両端点でリモート呼び出し可能な機能を提供し双方から利用する。
* **ストリーム**: ファイルのような大きなデータをストリームとして送受信する。
* **省リソース**: 非同期 I/O と組み合わせ単一の I/O セッション上で複数の RPC 呼び出しを同時に実行する。
* **抽象性**: TCP, UDP, Unix Pipe や標準入出力など下層の I/O 実装に依存しない。

## Components

![class chart](https://raw.github.com/torao/kazzla/master/doc/images/biRPC-ClassChart.png)

biRPC は下層の I/O レイヤーと上層のリモート呼び出し可能な機能とを接続します。
I/O レイヤーは通信のための実装を隠蔽しメッセージのシリアライズ/デシリアライズを行います。

### Session

**セッション** は論理的な通信端点を表します (単純な TCP/IP 実装での Socket とおなじスコープを持ちます)。下層の I/O フレームワークとキューで接続し、通信相手から受信したメッセージでパイプの生成、破棄、転送を行います。

セッションには通信相手側から呼び出し可能な機能として 16 ビット整数で識別される複数の Function をバインドします。通信相手ごとにリモートへ提供する機能を変更することが出来ます。

### Pipe

**パイプ** は同一セッション上の通信端点がメッセージの宛先を示すために使用する仮想的な接続です (スコープは 1 function call です)。

パイプは通信端点の双方で共有する 16 ビットの識別子によって特定されます。相手側とのネゴシエーションなしに片方の端点単独でユニークなパイプ識別子を決定できるようにパイプ識別子の最上位ビットの使用について事前の取り決めが必要です。一般的な TCP/IP を用いた通信では接続を開始した側 (クライアント側) が 0x0000 マスク、通信を受けた側 (サーバ側) が 0x8000 マスクをセッションの間使用します。これは同一セッション上で片方の端点からオープンできるパイプは最大でも 0x7FFF 個であることも意味しています。また通信相手からの Open 命令に自分と同じマスクが使用されていた場合、パイプのユニークが保障されないためそのセッションは直ちに終了しなければなりません。

### Message

メッセージは下層の I/O レイヤーと通信するためのデータフレームです。biRPC で使用するメッセージは 3 種類あります。一つ目は **Open** であり、通信相手とのセッション上で特定の function との仮想的なパイプ (接続) を開始する命令です。Open メッセージはこれから形成しようとしているパイプの識別子、呼び出そうとしている function 識別子、function に渡すパラメータで構成されています。

二つ目のメッセージは **Close** です。セッション上でオープンされている特定のパイプがこれ以上使われなくなった事を示すために使用されます。Close メッセージは閉じようとしているパイプ識別子と function の実行結果またはエラー状況を知らせる文字列が付属します。Open に対して単純に Close で応答する手順は一般的な Request/Response で実現される RPC プロトコルのモデルと同じです。

三つ目のメッセージは **Block** です。オープン中のパイプに対してデータブロックを送信または受信するために使用されます。Block は宛先となるパイプ識別子に加えてデータを持ちます。

Block はパイプ上で抽象化されたデータストリームを形成することを目的としたメッセージです。パイプに対して双方向の通信チャネルとして利用できます。TCP/IP のパケットと同様に下層の通信レイヤーの実装によっては複数の Block に分割されたり一つの Block に統合される可能性がありますが順序性は保障されています (下層の I/O フレームワークによって保障される必要があります)。長さが 0 の Block はストリームの終端 (EOF) を意味します。Open によって呼び出された function は、自分が起動されたパイプからこのストリームを利用することが出来ます。

## Example
### Asynchronous RPC
例としてセッション中の通信端点 A, B があり、B 側に大文字を小文字に変換する function (識別子100) が提供されているものとします。この機能を A から利用する時のメッセージの流れは以下のようになります。

![Asynchronous RPC](https://raw.github.com/torao/kazzla/master/doc/images/biRPC-Sequence1.png)

A はセッション上で未使用のパイプ識別子 10 を新たな呼び出しのために割り当てメッセージ `Open(10, 100, "ABC")` を送信し直ちに処理を返します。B はセッション上に新しいパイプ 10 を割り当て function 100 を実行しメッセージ `Close(10, "abc")` を送信してパイプ 10 を破棄します。A はこの Close を受信するとパイプ 10 を破棄し実行結果 `"abc"` をコールバックします。

このような Open-Close の単純なセットからで行われる処理は非同期型の RPC と同じです。

### Asynchronous Streaming RPC
次にパイプ上に形成されたストリームを利用して A から B へデータを渡す場合のメッセージの流れを考えます。

![Unidirectional Asynchronous Streaming RPC](https://raw.github.com/torao/kazzla/master/doc/images/biRPC-Sequence2.png)

Asynchronous RPC との違いは Open 〜 Close 間にパイプ指定で Block の送受信が行われることだけです。上記の例では `Open(11, 101)` で function 101 へのパイプ 11 を A, B の双方で生成し、パイプ 11 宛てに A から B へ任意数のブロックを送信します。A は最後のデータブロックを送信すると EOF を表す長さ 0 のブロックを送信します。

function 101 は自分の呼び出されたコンテキストのパイプから受信したブロックを参照し、EOF で処理を終了を検知してすべての文字列を小文字にして返しています。

### Bidirectional Streaming, Recursive RPC
より複雑な処理では 1 つのパイプ上で双方向に Block が流れるでしょう。また B の function 実行中に A 側の function を呼び出すことも出来ます。

Close は上記の例で A からも B からも送信することが出来るが、デザイン上 Open を受けた方から送信されるのが望ましい。

* TODO 書きかけ。例示のシーケンス図作成。

## Data Presentation

データシリアライゼーションの標準実装は MessagePack を用意していますが、これを使用するかどうかは最終的に下層の I/O レイヤーにより選択されます。

### Supported Data-Type

* boolean型
* 8ビット整数
* 16ビット整数
* 32ビット整数
* 64ビット整数
* 文字列
* バイナリ
* UUID (128ビット)
* リスト (配列)
* マップ

## 雑記
### セキュリティ
biRPC ではセキュリティについての定義は行いません。通信経路上の暗号化及び通信相手の認証は下層の I/O フレームワークでの SSL/TLS レイヤーで行うことを前提としています。あるいは上層のアプリケーションレイヤーで独自の認証機構を実装する必要があります。

### 負荷分散
TCP セッションごとにクラスタ化された複数のノードへ処理を分散させることが可能です。また function に冪等性があるならばメッセージのフレームを認識しパイプ識別子ごとに分散させることが可能です。