/* Copyright (C) 2012 BJöRFUAN
 * This source and related resources are distributed under Apache License, Version 2.0.
 */
package com.kazzla.drpc.async

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// AsyncSocketIOContext: 非同期 I/O コンテキスト
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/**
 * SocketChannel を使用した非同期 I/O のためのクラスです。スレッドプールを保持しています。
 * @author Takami Torao
 */
class AsyncSocketIOContext {

	// ========================================================================
	// 1スレッドあたりのソケット数
	// ========================================================================
	/**
	 * 1スレッドが担当するソケット数の上限です。
	 */
	private var _maxSocketsPerThread = 512

	// ========================================================================
	// 1スレッドあたりのソケット数
	// ========================================================================
	/**
	 * 1スレッドが担当するソケット数の上限を設定します。スレッドの担当するソケット数がこの
	 * 数を超えると新しいスレッドが生成されます。
	 */
	def maxSocketsPerThread_=(count:Int):Unit = {
		this._maxSocketsPerThread = count
	}

	// ========================================================================
	// 1スレッドあたりのソケット数
	// ========================================================================
	/**
	 * 1スレッドが担当するソケット数の上限を参照します。
	 */
	def maxSocketsPerThread:Int = _maxSocketsPerThread

	// ========================================================================
	// 読み込みバッファサイズ
	// ========================================================================
	/**
	 * 1スレッドが使用する読み込みバッファサイズです。
	 */
	var readBufferSize = 4 * 1024

	// ========================================================================
	// ワーカースレッド
	// ========================================================================
	/**
	 * 実行中のワーカースレッドです。
	 */
	private var workers = List[Worker]()

	// ========================================================================
	// エンドポイントの追加
	// ========================================================================
	/**
	 * このコンテキストに新しいエンドポイントを参加します。
	 * @param endpoint 参加するエンドポイント
	 */
	def join(endpoint:Endpoint):Unit = {
		val worker = synchronized{
			workers.reverse.find{ worker => worker.socketCount < maxSocketsPerThread } match {
				case Some(worker) => worker
				case None =>
					val worker = new Worker(readBufferSize)
					worker.start()
					workers ::= worker
					worker
			}
		}
		worker.join(endpoint)
	}

	// ========================================================================
	// エンドポイントの切り離し
	// ========================================================================
	/**
	 * このコンテキストから指定されたエンドポイントを除去します。
	 * 除去したエンドポイントを別のコンテキストに送受信を再開させることができます。
	 * @param endpoint 切り離すエンドポイント
	 */
	/*
	def leave(endpoint:Endpoint):Unit = {
		val worker = synchronized{
			workers.find{ worker =>
				worker.leave(channel) match {
					case Some(peer) =>
				}
			} }
	}
	*/

}
