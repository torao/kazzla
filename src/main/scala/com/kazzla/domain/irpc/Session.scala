/* Copyright (C) 2012 BJöRFUAN
 * This source and related resources are distributed under Apache License, Version 2.0.
 */
package com.kazzla.irpc

import async.PipelineGroup
import java.util.{TimerTask, Timer}
import collection.mutable.HashMap

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Session
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/**
 * <p>
 * 異なるセッション間で接続が共有されることはありません。
 * </p>
 * @author Takami Torao
 */


class Session private[irpc](val domain:Domain) {

	// ========================================================================
	// パイプライングループ
	// ========================================================================
	/**
	 * このノード上での非同期入出力を行うパイプライングループです。
	 */
	private[irpc] val context = new PipelineGroup()

	// ========================================================================
	// 呼び出し処理
	// ========================================================================
	/**
	 * このセッション上で現在実行中の呼び出し処理です。
	 */
	private[this] val tasks = new HashMap[Call, Task]()

	// ========================================================================
	// ========================================================================
	/**
	 * 指定された転送単位を転送します。
	 * 指定されたデータブロックを転送します。
	 */
	def lookupService[T <: Service] (name:String, interface:Class[T]):T ={

	}

	// ========================================================================
	// ========================================================================
	/**
	 * 指定された転送単位を転送します。
	 * 指定されたデータブロックを転送します。
	 */
	def lookupNode()

	// ========================================================================
	// シャットダウンフラグ
	// ========================================================================
	/**
	 * このノードがシャットダウン中かを表すフラグです。
	 */
	@volatile
	private var closing = false

	// ========================================================================
	// セッションのクローズ
	// ========================================================================
	/**
	 * このセッションをクローズし使用していたリソースを全て開放します。
	 */
	def close() {
		Session.remove(this)
	}

	// ========================================================================
	// セッションのクリーンアップ
	// ========================================================================
	/**
	 * このセッション上で確保されている不必要なリソースを開放します。
	 */
	private[Session] def cleanup(): Unit = {
		// TODO タイムアウトした処理の停止
	}

}

object Session {

	// ========================================================================
	// タイムアウト監視タイマー
	// ========================================================================
	/**
	 * 全てのセッション上で実行されている呼び出し処理のタイムアウトを監視するタイマーです。
	 */
	private[Session] val timer = new Timer("SessionTimeoutWatchdog", true)
	timer.scheduleAtFixedRate(new TimerTask {
		def run() {
			cleanup()
		}
	}, 3000, 3000)

	// ========================================================================
	// セッション
	// ========================================================================
	/**
	 * 実行中のセッションです。
	 */
	private[Session] var sessions = List[Session]()

	// ========================================================================
	// セッションの追加
	// ========================================================================
	/**
	 * 指定されたセッションを監視に追加します。
	 */
	private[Session] def add(session: Session): Unit = synchronized {
		sessions ::= session
	}

	// ========================================================================
	// セッションの削除
	// ========================================================================
	/**
	 * 指定されたセッションを監視から除去します。
	 */
	private[Session] def remove(session: Session): Unit = synchronized {
		sessions = sessions.filter {
			s => !s.eq(session)
		}
	}

	// ========================================================================
	// セッション監視タスク
	// ========================================================================
	/**
	 * すべてのセッションの自己監視処理を起動します。
	 */
	private[this] def cleanup(): Unit = {
		sessions.foreach {
			_.cleanup()
		}
	}

}