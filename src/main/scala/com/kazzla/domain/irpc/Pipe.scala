/* Copyright (C) 2012 BJöRFUAN
 * This source and related resources are distributed under Apache License, Version 2.0.
 */
package com.kazzla.domain.irpc

import java.io.{OutputStream, InputStream}
import java.nio.ByteBuffer

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Pipe
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/**
 * @author Takami Torao
 */
trait Pipe {

	// ========================================================================
	// ID
	// ========================================================================
	/**
	 */
	def id:Long

	// ========================================================================
	// 入力ストリーム
	// ========================================================================
	/**
	 */
	def in:InputStream

	// ========================================================================
	// 出力ストリーム
	// ========================================================================
	/**
	 */
	def out:OutputStream

	// ========================================================================
	// バルク転送
	// ========================================================================
	/**
	 * 指定されたバイナリデータをバルク転送します。
	 */
	def bulkTransfer(buffer:ByteBuffer):Unit

	// ========================================================================
	// キャンセルフラグ
	// ========================================================================
	/**
	 * このパイプがキャンセルされたかを表すフラグです。パイプに対するキャンセル操作はパイプ
	 * の双方が行うことができます。
	 * このメソッドを呼び出すことにより Cancel コードの Close が相手に転送されパイプは
	 * クローズされます。
	 * @param reason キャンセルの理由
	 */
	def cancel(reason:String = "operation canceled"):Unit

	// ========================================================================
	// キャンセルの判定
	// ========================================================================
	/**
	 * このパイプが自分または相手側によってキャンセルされているかを判定します。
	 * @return キャンセルされている場合 true
	 */
	def isCanceled:Boolean

	// ========================================================================
	// 結果の参照
	// ========================================================================
	/**
	 * 処理をブロックし RPC の実行結果を参照します。リモート側で例外が発生した場合は例外が
	 * スローされます。
	 * @param timeout 応答までのタイムアウト時間 (ミリ秒)
	 * @throws RemoteException リモート側で例外が発生した場合
	 * @throws CancelException 待機中に処理がキャンセルされた場合
	 */
	def apply(timeout:Long = 0):Seq[Any] = get(timeout) match {
		case Some(close) =>
			close.code match {
				case Close.Code.EXIT => close.args
				case Close.Code.ERROR | Close.Code.FATAL | Close.Code.CANCEL | Close.Code.NONE =>
					throw new RemoteException(close.message)
			}
		case None =>
			throw new RemoteException("return timeout")
	}

	// ========================================================================
	// 結果の参照
	// ========================================================================
	/**
	 * 結果を参照します。指定されたタイムアウトまでに結果のリターンがなかった場合は None
	 * を返します。指定された待ち時間までに応答がなかった場合は None を返します。
	 * 待ち時間に 0 を指定した場合、応答があるまで永遠に待機します。この場合 None が返る
	 * ことはありません。
	 * @param timeout 応答待ち時間 (ミリ秒)
	 * @return RPC 実行結果
	 */
	def get(timeout:Long):Option[Close]

}

object Pipe {
	private[this] val pipe = new ThreadLocal[Pipe]()
	def apply():Option[Pipe] = Option(pipe.get())
	private[irpc] def setPipe(pipe:Option[Pipe]) = { this.pipe.set(pipe.getOrElse(null)) }
}